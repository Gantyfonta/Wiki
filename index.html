<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Infinite Wiki</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kosugi&display=swap" rel="stylesheet">
    <style>
      @keyframes blink {
        from, to { opacity: 1 }
        50% { opacity: 0; }
      }
      @keyframes skeleton-glow {
        from { background-color: #e0e0e0; }
        to { background-color: #f0f0f0; }
      }

      body {
        background-color: #ffffff;
        color: #000000;
        font-family: 'Kosugi', sans-serif;
        font-size: 1.1rem; /* Set base font size for the entire app */
        line-height: 1.6; /* Set base line height for readability */
        margin: 0;
        padding: 2rem 2rem 5rem 2rem; /* Increased bottom padding for sticky footer */
      }
      #root {
        max-width: 65ch; /* Optimal line length for readability */
        margin: auto;
      }
      h1, h2, h3, h4, h5, h6 {
        font-size: 1em; /* 1em equals the parent font-size, which is 1.1rem from body */
        margin: 0;
        font-weight: normal; /* Ensure no bolding by default */
      }
      button {
        background: none;
        border: none;
        padding: 0;
        font: inherit;
        color: inherit;
        cursor: pointer;
      }
      .interactive-word {
        color: #000000;
        text-decoration: none;
        transition: color 0.2s ease-in-out;
      }
      .interactive-word:hover {
        color: #0000ff;
        text-decoration: underline;
      }
      .footer-text {
        font-size: 0.9em;
        color: #888;
      }
      .footer-text a {
        color: inherit;
        text-decoration: none;
        transition: color 0.2s ease-in-out;
      }
      .footer-text a:hover {
        color: #0000ff;
        text-decoration: underline;
      }
      .ascii-art {
        font-family: monospace;
        text-align: left;
        white-space: pre;
        color: #888;
        margin: 2rem 0;
        line-height: 1.1;
        font-size: 0.8em;
      }
      .blinking-cursor {
        animation: blink 1s step-end infinite;
      }
      .search-container {
        display: flex;
        align-items: baseline;
        gap: 1rem;
        margin-bottom: 3rem;
      }
      .search-form {
        flex-grow: 1;
      }
      .search-input {
        width: 100%;
        padding: 0.5rem 0.2rem;
        font: inherit;
        color: inherit;
        border: none;
        border-bottom: 1px solid transparent;
        background-color: transparent;
        box-sizing: border-box;
        outline: none;
      }
      .search-input:disabled {
        color: #ccc;
      }
      .search-input::placeholder {
        color: #000000;
        opacity: 1;
      }
      .random-button {
        background: none;
        border: none;
        padding: 0.5rem 0;
        font: inherit;
        color: #000000;
        cursor: pointer;
        white-space: nowrap;
      }
      .random-button:hover:not(:disabled) {
        color: #0000ff;
      }
      .random-button:disabled {
        color: #ccc;
        cursor: not-allowed;
      }
      .sticky-footer {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        text-align: center;
        padding: 1.5rem 0;
        background-color: #ffffff;
      }
      .skeleton-bar {
        height: 1rem;
        margin-bottom: 0.75rem;
        animation: skeleton-glow 1.5s ease-in-out infinite alternate;
      }
      .search-results-container {
        margin-top: 2.5rem;
        border-top: 1px solid #e0e0e0;
        padding-top: 2rem;
      }
      .search-results-heading {
        font-size: 0.8em;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        margin-bottom: 1.5rem;
        font-weight: 600;
      }
      .search-result {
        margin-bottom: 1rem;
      }
      .search-result-link {
        display: block;
        font-size: 1em;
        color: #0000ff;
        text-decoration: none;
        margin-bottom: 0.25rem;
      }
      .search-result-link:hover {
        text-decoration: underline;
      }
      .search-result-uri {
        font-size: 0.8em;
        color: #888;
        word-break: break-all;
        margin: 0;
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "@google/genai": "https://esm.sh/@google/genai@^1.7.0"
  }
}
</script>
</head>
<body>
    <div id="root" style="display: none;">
        <div class="search-container">
            <form id="search-form" class="search-form" role="search">
                <input type="text" id="search-input" placeholder="Search" class="search-input" aria-label="Search for a topic">
            </form>
            <button id="random-button" class="random-button">Random</button>
        </div>
        
        <header style="text-align: center; margin-bottom: 2rem;">
            <h1 style="letter-spacing: 0.2em; text-transform: uppercase;">INFINITE WIKI</h1>
            <pre id="ascii-art" class="ascii-art" aria-label="ASCII art for the current topic">*</pre>
        </header>
        
        <main>
            <div>
                <h2 id="topic-title" style="margin-bottom: 2rem; text-transform: capitalize;"></h2>
                <div id="error-display" style="display: none; border: 1px solid #cc0000; padding: 1rem; color: #cc0000;">
                  <p style="margin: 0;">An Error Occurred</p>
                  <p id="error-message" style="margin-top: 0.5rem; margin: 0;"></p>
                </div>
                <div id="content-display">
                    <!-- Content or skeleton loader goes here -->
                </div>
                <div id="search-results-container" style="display: none;"></div>
            </div>
        </main>
    
        <footer class="sticky-footer">
            <p class="footer-text" style="margin: 0;">
                Infinite Wiki by <a href="https://x.com/dev_valladares" target="_blank" rel="noopener noreferrer">Dev Valladares</a> · Generated by Gemini
                <span id="generation-time"></span>
            </p>
        </footer>
    </div>
    <script type="module">
        import { GoogleGenAI } from '@google/genai';

        // --- 1. CONFIGURATION & CONSTANTS ---
        let API_KEY = '__GEMINI_API_KEY__'; // This is replaced by the GitHub Action workflow
        const PREDEFINED_WORDS = ['Balance', 'Harmony', 'Discord', 'Unity', 'Fragmentation', 'Clarity', 'Ambiguity', 'Presence', 'Absence', 'Creation', 'Destruction', 'Light', 'Shadow', 'Beginning', 'Ending', 'Rising', 'Falling', 'Connection', 'Isolation', 'Hope', 'Despair', 'Order and chaos', 'Light and shadow', 'Sound and silence', 'Form and formlessness', 'Being and nonbeing', 'Presence and absence', 'Motion and stillness', 'Unity and multiplicity', 'Finite and infinite', 'Sacred and profane', 'Memory and forgetting', 'Question and answer', 'Search and discovery', 'Journey and destination', 'Dream and reality', 'Time and eternity', 'Self and other', 'Known and unknown', 'Spoken and unspoken', 'Visible and invisible', 'Zigzag', 'Waves', 'Spiral', 'Bounce', 'Slant', 'Drip', 'Stretch', 'Squeeze', 'Float', 'Fall', 'Spin', 'Melt', 'Rise', 'Twist', 'Explode', 'Stack', 'Mirror', 'Echo', 'Vibrate', 'Gravity', 'Friction', 'Momentum', 'Inertia', 'Turbulence', 'Pressure', 'Tension', 'Oscillate', 'Fractal', 'Quantum', 'Entropy', 'Vortex', 'Resonance', 'Equilibrium', 'Centrifuge', 'Elastic', 'Viscous', 'Refract', 'Diffuse', 'Cascade', 'Levitate', 'Magnetize', 'Polarize', 'Accelerate', 'Compress', 'Undulate', 'Liminal', 'Ephemeral', 'Paradox', 'Zeitgeist', 'Metamorphosis', 'Synesthesia', 'Recursion', 'Emergence', 'Dialectic', 'Apophenia', 'Limbo', 'Flux', 'Sublime', 'Uncanny', 'Palimpsest', 'Chimera', 'Void', 'Transcend', 'Ineffable', 'Qualia', 'Gestalt', 'Simulacra', 'Abyssal', 'Existential', 'Nihilism', 'Solipsism', 'Phenomenology', 'Hermeneutics', 'Deconstruction', 'Postmodern', 'Absurdism', 'Catharsis', 'Epiphany', 'Melancholy', 'Nostalgia', 'Longing', 'Reverie', 'Pathos', 'Ethos', 'Logos', 'Mythos', 'Anamnesis', 'Intertextuality', 'Metafiction', 'Stream', 'Lacuna', 'Caesura', 'Enjambment'];
        const UNIQUE_WORDS = [...new Set(PREDEFINED_WORDS)];

        let ai;
        const artModelName = 'gemini-2.5-flash';
        const textModelName = 'gemini-2.5-flash';
        const ENABLE_THINKING_FOR_ASCII_ART = false;

        // --- 2. DOM ELEMENT REFERENCES ---
        const rootContainer = document.getElementById('root');
        const searchForm = document.getElementById('search-form');
        const searchInput = document.getElementById('search-input');
        const randomButton = document.getElementById('random-button');
        const asciiArtPre = document.getElementById('ascii-art');
        const topicTitle = document.getElementById('topic-title');
        const contentDisplay = document.getElementById('content-display');
        const searchResultsContainer = document.getElementById('search-results-container');
        const errorDisplay = document.getElementById('error-display');
        const errorMessageEl = document.getElementById('error-message');
        const generationTimeSpan = document.getElementById('generation-time');

        // --- 3. STATE MANAGEMENT ---
        let currentTopic = '';
        let isLoading = false;
        let asciiArtInterval;
        let generationStartTime;

        // --- 4. GEMINI SERVICE FUNCTIONS ---
        const createFallbackArt = (topic) => {
          const displayableTopic = topic.length > 20 ? topic.substring(0, 17) + '...' : topic;
          const paddedTopic = ` ${displayableTopic} `;
          const topBorder = `┌${'─'.repeat(paddedTopic.length)}┐`;
          const middle = `│${paddedTopic}│`;
          const bottomBorder = `└${'─'.repeat(paddedTopic.length)}┘`;
          return { art: `${topBorder}\n${middle}\n${bottomBorder}` };
        };
        
        async function generateDefinitionAndSearchResults(topic) {
            if (!ai) throw new Error('Gemini AI is not initialized.');
            const prompt = `Provide a concise, single-paragraph encyclopedia-style definition for the term: "${topic}". Be informative and neutral. Do not use markdown, titles, or any special formatting. Respond with only the text of the definition itself.`;
            
            try {
                const response = await ai.models.generateContent({
                    model: textModelName,
                    contents: prompt,
                    config: {
                        tools: [{googleSearch: {}}],
                    },
                });

                return {
                    definition: response.text,
                    searchResults: response.candidates?.[0]?.groundingMetadata?.groundingChunks ?? [],
                };
            } catch (error) {
                console.error(`Error generating content for "${topic}":`, error);
                throw new Error(`Failed to generate content. ${error.message}`);
            }
        }

        async function generateAsciiArt(topic) {
            if (!ai) throw new Error('Gemini AI is not initialized.');
            const artPromptPart = `1. "art": meta ASCII visualization of the word "${topic}":\n- Palette: │─┌┐└┘├┤┬┴┼►◄▲▼○●◐◑░▒▓█▀▄■□▪▫★☆♦♠♣♥⟨⟩/\\_|\n- Shape mirrors concept - make the visual form embody the word's essence\n- Examples: \n  * "explosion" → radiating lines from center\n  * "hierarchy" → pyramid structure\n  * "flow" → curved directional lines\n- Return as single string with \\n for line breaks`;
            const prompt = `For "${topic}", create a JSON object with one key: "art".\n${artPromptPart}\n\nReturn ONLY the raw JSON object, no additional text. The response must start with "{" and end with "}" and contain only the art property.`;
            try {
                const config = { responseMimeType: 'application/json' };
                if (!ENABLE_THINKING_FOR_ASCII_ART) {
                    config.thinkingConfig = { thinkingBudget: 0 };
                }
                const response = await ai.models.generateContent({ model: artModelName, contents: prompt, config: config });
                let jsonStr = response.text.trim().match(/\{.*\}/s)?.[0] || '{}';
                const parsedData = JSON.parse(jsonStr);
                if (typeof parsedData.art !== 'string' || parsedData.art.trim().length === 0) {
                    throw new Error('Invalid or empty ASCII art in response');
                }
                return parsedData;
            } catch (error) {
                console.warn(`Failed to generate ASCII art for "${topic}":`, error.message);
                return createFallbackArt(topic);
            }
        }

        // --- 5. UI UPDATE FUNCTIONS ---
        function toggleLoading(loading) {
            isLoading = loading;
            searchInput.disabled = loading;
            randomButton.disabled = loading;
        }
        
        function displayAsciiArt(artData) {
            if (asciiArtInterval) clearInterval(asciiArtInterval);
            let visibleContent = '';
            asciiArtPre.textContent = '';
            let isStreaming = true;

            const fullText = artData.art;
            let currentIndex = 0;
            const cursor = document.createElement('span');
            cursor.className = 'blinking-cursor';
            cursor.textContent = '|';

            asciiArtInterval = setInterval(() => {
                if (currentIndex < fullText.length) {
                    visibleContent += fullText[currentIndex];
                    asciiArtPre.textContent = visibleContent;
                    if(isStreaming) asciiArtPre.appendChild(cursor);
                    currentIndex++;
                } else {
                    clearInterval(asciiArtInterval);
                    isStreaming = false;
                    asciiArtPre.textContent = fullText;
                }
            }, 5);
        }

        function displayContent(fullContent) {
            contentDisplay.innerHTML = '';
            const p = document.createElement('p');
            p.style.margin = 0;

            const words = fullContent.split(/(\s+)/);
            words.forEach(word => {
                if (/\S/.test(word)) {
                    const cleanWord = word.replace(/[.,!?;:()"']/g, '');
                    if (cleanWord) {
                        const button = document.createElement('button');
                        button.textContent = word;
                        button.className = 'interactive-word';
                        button.setAttribute('aria-label', `Learn more about ${cleanWord}`);
                        button.dataset.word = cleanWord;
                        p.appendChild(button);
                    } else {
                        const span = document.createElement('span');
                        span.textContent = word;
                        p.appendChild(span);
                    }
                } else {
                    const span = document.createElement('span');
                    span.textContent = word;
                    p.appendChild(span);
                }
            });
            contentDisplay.appendChild(p);
        }

        function displaySearchResults(results) {
            searchResultsContainer.innerHTML = '';
            searchResultsContainer.style.display = 'none';

            if (!results || results.length === 0) return;

            const validResults = results.filter(r => r.web && r.web.uri && r.web.title);
            if (validResults.length === 0) return;

            const heading = document.createElement('h3');
            heading.className = 'search-results-heading';
            heading.textContent = 'Top Web Result';
            searchResultsContainer.appendChild(heading);

            const topResult = validResults[0].web;

            const item = document.createElement('div');
            item.className = 'search-result';

            const link = document.createElement('a');
            link.className = 'search-result-link';
            link.href = topResult.uri;
            link.textContent = topResult.title;
            link.target = '_blank';
            link.rel = 'noopener noreferrer';

            const uri = document.createElement('p');
            uri.className = 'search-result-uri';
            uri.textContent = topResult.uri;
            
            item.appendChild(link);
            item.appendChild(uri);
            searchResultsContainer.appendChild(item);

            searchResultsContainer.style.display = 'block';
        }

        function renderSkeletonLoader() {
            contentDisplay.innerHTML = ''; // Clear previous content
            for (let i = 0; i < 5; i++) {
                const bar = document.createElement('div');
                bar.className = 'skeleton-bar';
                bar.style.width = `${Math.random() * 40 + 60}%`; // Random widths for realism
                contentDisplay.appendChild(bar);
            }
        }

        function showError(message) {
          errorMessageEl.textContent = message;
          errorDisplay.style.display = 'block';
          contentDisplay.innerHTML = ''; // Clear content/skeleton
        }

        function hideError() {
          errorDisplay.style.display = 'none';
        }

        // --- 6. CORE APPLICATION LOGIC ---
        async function fetchAndDisplayTopic(topic) {
            if (isLoading || !topic || topic.trim() === '') return;

            const normalizedTopic = topic.trim().toLowerCase();
            if (currentTopic === normalizedTopic) return;
            
            toggleLoading(true);
            hideError();
            generationStartTime = Date.now();
            generationTimeSpan.textContent = '';
            currentTopic = normalizedTopic;
            
            searchInput.value = currentTopic;
            topicTitle.textContent = currentTopic;
            window.location.hash = encodeURIComponent(currentTopic);

            renderSkeletonLoader();
            displayAsciiArt({ art: '...' });
            searchResultsContainer.style.display = 'none';
            searchResultsContainer.innerHTML = '';

            try {
                const artPromise = generateAsciiArt(currentTopic);
                const contentPromise = generateDefinitionAndSearchResults(currentTopic);
                
                const [artData, contentData] = await Promise.all([artPromise, contentPromise]);

                displayAsciiArt(artData);

                if (contentData.definition && contentData.definition.trim().length > 0) {
                    contentDisplay.innerHTML = ''; // Clear skeleton
                    displayContent(contentData.definition);
                } else {
                    throw new Error("No definition was generated. The topic might be too specific or new.");
                }
                
                displaySearchResults(contentData.searchResults);

            } catch (error) {
                console.error("Error fetching topic:", error);
                const userFriendlyMessage = error.message.includes('API key') 
                    ? 'API key is invalid or missing. Please check your configuration.'
                    : error.message.includes("No definition")
                    ? error.message
                    : `Failed to load content for "${currentTopic}". Please try another topic.`;
                showError(userFriendlyMessage);
            } finally {
                toggleLoading(false);
                const endTime = Date.now();
                const duration = ((endTime - generationStartTime) / 1000).toFixed(2);
                generationTimeSpan.textContent = ` · ${duration}s`;
            }
        }

        // --- 7. EVENT LISTENERS ---
        searchForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const searchTerm = searchInput.value.trim();
            if (searchTerm) {
                fetchAndDisplayTopic(searchTerm);
            }
        });

        randomButton.addEventListener('click', () => {
            const randomIndex = Math.floor(Math.random() * UNIQUE_WORDS.length);
            const randomWord = UNIQUE_WORDS[randomIndex];
            fetchAndDisplayTopic(randomWord);
        });

        contentDisplay.addEventListener('click', (e) => {
            const target = e.target;
            if (target.classList.contains('interactive-word')) {
                const word = target.dataset.word;
                if (word) {
                    fetchAndDisplayTopic(word);
                }
            }
        });

        window.addEventListener('hashchange', () => {
            const newTopic = decodeURIComponent(window.location.hash.substring(1));
            if (newTopic && newTopic !== currentTopic) {
                fetchAndDisplayTopic(newTopic);
            }
        });

        // --- 8. INITIALIZATION ---
        function init() {
            if (API_KEY === '__GEMINI_API_KEY__') {
                const storedKey = sessionStorage.getItem('gemini_api_key');
                if (storedKey) {
                    API_KEY = storedKey;
                } else {
                    const userKey = prompt('Gemini API Key not found. Please enter your key for local development. It will be stored for this session only.');
                    if (userKey) {
                        API_KEY = userKey;
                        sessionStorage.setItem('gemini_api_key', userKey);
                    } else {
                        document.body.innerHTML = '<div style="text-align: center; padding: 2rem;">An API key is required to use this application. Please reload and provide a valid key.</div>';
                        return;
                    }
                }
            }

            try {
                ai = new GoogleGenAI({ apiKey: API_KEY });
            } catch(e) {
                 document.body.innerHTML = `<div style="text-align: center; padding: 2rem;">Failed to initialize Gemini AI. The API key might be invalid. Please check the console for details.</div>`;
                 console.error(e);
                 return;
            }

            rootContainer.style.display = 'block';
            const initialTopic = decodeURIComponent(window.location.hash.substring(1)) || 'serendipity';
            fetchAndDisplayTopic(initialTopic);
        }

        init();
    </script>
</body>
</html>